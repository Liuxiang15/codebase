<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

</head>

<body>
    <div id="app"></div>
    <script src="./observer.js"></script>
    <script src="./vue.js"></script>
    <script>
        let vm = new Vue({
            el: '#app',
            data: {
                msg: '123',
                age: 18
            }
        })
        console.log(vm)
    </script>

    <script>
        // 4、在Vue 响应式中应用到了 发布订阅模式 我们先来了解下

        // 首先来说简单介绍下 一共有三个角色
        //  发布者、 订阅者、  信号中心  
        // 举个现实中例子 作者(发布者)写一篇文章 发到了掘金(信号中心), 掘金可以处理文章然后推送到了首页，然后各自大佬(订阅者)就可以订阅文章


        // class Vue {
        //     constructor() {
        //         // 存储时间和回调
        //         this._subs = {}
        //     }
        //     // 监听
        //     $on (type, fn) {
        //         const callbacks = this._subs[type] || []
        //         callbacks.push(fn)
        //         this._subs[type] = callbacks
        //     }
        //     $emit (type, ...args) {
        //         const callbacks = this._subs[type] || []
        //         callbacks.forEach(fn => fn(...args))
        //     }

        // }

        // const evevtBus = new Vue()
        // // 监听sum
        // evevtBus.$on('sum', function (...args) {
        //     const total = args.reduce((prev, next) => prev + next, 0)
        //     console.log(total)
        // })
        // // 触发sum
        // evevtBus.$emit('sum', 1, 2, 4, 5)

        //  5.观察者模式 与 发布订阅 的差异

        // 与发布订阅者不同 观察者中 发布者和订阅者(观察者)是相互依赖的 必须要求观察者订阅内容改变事件 ，而发布订阅者是由调度中心进行调度，那么看看观察者模式 是如何相互依赖

        // 目标
        class Subject {
            constructor() {
                this._observeLists = []
            }
            // 添加观察者
            addObs (obs) {
                if (obs && obs.update) {
                    // 添加到观察者列表中
                    this._observeLists.push(obs)
                }
            }
            // 通知观察者
            notify () {
                this._observeLists.forEach(obs => {
                    // 每个观察者受到通知后 更新事件
                    obs.update()
                })
            }
            // 清空观察者
            empty () {
                this._observeLists = []
            }
        }

        // class Observer {
        //     // 定义观察者内容更新事件
        //     update () {
        //         console.log('目标更新了')
        //     }
        // }
        // 测试
        // let sub = new Subject()
        // let obs1 = new Observer(),
        //     obs2 = new Observer()
        // sub.addObs(obs1)
        // sub.addObs(obs2)
        // sub.notify()




    </script>
</body>


</html>