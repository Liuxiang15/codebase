
参考博客：什么是重绘和重排？https://blog.csdn.net/qq_39998026/article/details/125441268
## 重绘和回流

重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。

- 重绘：当节点需要更改外观而不会影响布局的，比如改变 *color* 就叫称为重绘
- 回流：布局或者几何属性需要改变就称为回流。

**回流必定会发生重绘，重绘不一定会引发回流。**因此回流所需的成本比重绘高得多，改变父节点里的子节点很可能会导致父节点的一系列回流。

引起重绘的属性：

外观属性包括界面、文字等可用状态向量描述的属性，如：

界面：appearance、outline、background、mask、box-shadow、box-reflect、filter、opacity、clip、border-radius、background-size、visibility

文字：text、font、word

当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：

- 添加或删除可见的 *DOM* 元素

- 元素的位置发生变化

- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）

- 内容发生变化，（例如：文本改变或图片被另一个不同尺寸的图片替代、在input框输入内容）

- 页面一开始渲染的时候（这肯定避免不了）

- 浏览器的窗口尺寸变化（resize事件发生时，因为回流是根据视口的大小来计算元素的位置和大小的）

- 设置style属性的值

- 计算offsetWidth、offsetHeight、offsetTop和offsetLeft等布局信息

- 激活CSS伪类（如 :hover）

- 查询某些属性或调用某些方法（如：getComputedStyle()、getBoundingClientRect()）

### 现代浏览器的优化机制

现代的浏览器都是很聪明的，由于每次重排（回流）都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。

浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。

但是，当你获取布局信息的操作的时候，会强制队列刷新，比如当你访问以下属性或者使用以下方法：

- *offsetTop、offsetLeft、offsetWidth、offsetHeight*

- *scrollTop、scrollLeft、scrollWidth、scrollHeight*

- *clientTop、clientLeft、clientWidth、clientHeight*

- *getComputedStyle( )*

- *getBoundingClientRect*

更多会触发回流的属性和方法可以参阅：*https://gist.github.com/paulirish/5d52fb081b3570c81e3a*

### 减少回流和重绘的方式

接下来，让我们谈谈如何减少回流和重绘。

#### 1. 合并多次对 *DOM* 和样式的修改

由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对 *DOM* 和样式的修改，然后一次处理掉。考虑这个例子：

```js
const el = document.getElementById('test');
el.style.padding = '5px';
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
```

例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。

当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。

因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式。

使用 *cssText*

```js
const el = document.getElementById('test'); 
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; 
```

将要修改的 *CSS* 样式写在一个样式类里面，然后通过添加和删除该样式类的方式来改变样式

```js
const el = document.getElementById('test'); 
el.className += ' active'; 
```

#### 2. 批量修改 *DOM*

当我们需要对 *DOM* 对一系列修改的时候，可以通过以下步骤减少回流重绘次数：

1. 使元素脱离文档流

2. 对其进行多次修改

3. 将元素带回到文档中。

该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对 *DOM* 的所有修改都不会引起回流，因为它已经不在渲染树了。

有三种方式可以让 *DOM* 脱离文档流：

- 隐藏元素，应用修改，重新显示

- 使用文档片段（ *document fragment* ）在当前 *DOM* 之外构建一个子树，再把它拷贝回文档。

- 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。

考虑我们要执行一段批量插入节点的代码：

```js
function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i < data.length; i++) {
        li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}

const ul = document.getElementById('list');
appendDataToElement(ul, data);
```

如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。

我们可以使用上面所提到的三种方式进行优化。

（1）隐藏元素，应用修改，重新显示

这个会在展示和隐藏节点的时候，产生两次重绘。

```js
function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i < data.length; i++) {
        li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}
const ul = document.getElementById('list');
ul.style.display = 'none';
appendDataToElement(ul, data);
ul.style.display = 'block';
```

（2）使用文档片段（ *document fragment* ）在当前 *DOM* 之外构建一个子树，再把它拷贝回文档

```js
const ul = document.getElementById('list');
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);
```

（3）将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。

```js
const ul = document.getElementById('list');
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);
```

#### 3. 避免触发同步布局事件

上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。

举个例子，比如说我们想将一个 *p* 标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：

```js
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = box.offsetWidth + 'px';
    }
}
```

这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。

在每次循环的时候，都读取了 *box* 的一个 *offsetWidth* 属性值，然后利用它来更新 *p* 标签的 *width* 属性。

这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列，一刷新队列就会引发回流和重绘。

我们可以优化为：

```js
const width = box.offsetWidth;
function initP() {
    for (let i = 0; i < paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';
    }
}
```

#### 4. 复杂动画脱离文档流

对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。

#### 5. *CSS3* 硬件加速（ *GPU* 加速 ）

比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。

使用 *CSS3* 硬件加速，可以让 *transform、opacity、filters* 这些动画不会引起回流重绘。但是对于动画的其它属性，比如 *background-color* 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

常见的触发硬件加速的 *CSS* 属性：

- *transform*

- *opacity*

- *filters*

- *Will-change*
